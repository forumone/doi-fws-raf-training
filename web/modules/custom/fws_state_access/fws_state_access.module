<?php

/**
 * @file
 * Contains fws_state_access.module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\user\Entity\User;
use Drupal\Core\Logger\RfcLogLevel;
use Drupal\node\NodeInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\taxonomy\Entity\Term;

/**
 * Gets the state value for a user entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $user
 *   The user entity.
 *
 * @return mixed
 *   The state value or NULL if not available.
 */
function fws_state_access_get_user_state(EntityInterface $user) {
  if (!$user->hasField('field_state_cd') || $user->get('field_state_cd')->isEmpty()) {
    return NULL;
  }

  return $user->get('field_state_cd')->target_id;
}

/**
 * Gets the state value for a node entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $node
 *   The node entity.
 *
 * @return mixed
 *   The state value or NULL if not available.
 */
function fws_state_access_get_node_state(EntityInterface $node) {
  if (!$node->hasField('field_owner_state') || $node->get('field_owner_state')->isEmpty()) {
    return NULL;
  }

  return $node->get('field_owner_state')->target_id;
}

/**
 * Implements hook_entity_access().
 */
function fws_state_access_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
  // Check if user has the state access permission.
  if (!$account->hasPermission('access state based content')) {
    return AccessResult::neutral();
  }

  // Allow users with 'administer users' permission to bypass state restrictions for user entities.
  if ($entity->getEntityTypeId() === 'user' && $account->hasPermission('administer users')) {
    return AccessResult::neutral();
  }

  // Only apply restrictions to specific entity types and bundles.
  $restricted_entities = [
    'node' => ['species_image', 'permit_3186a'],
    'user' => ['user'],
  ];

  $entity_type = $entity->getEntityTypeId();
  $bundle = $entity->bundle();

  // If this is not a restricted entity type or bundle, return neutral.
  if (!isset($restricted_entities[$entity_type]) ||
      !in_array($bundle, $restricted_entities[$entity_type])) {
    return AccessResult::neutral();
  }

  // Get the user's state code.
  $user = User::load($account->id());
  $user_state = fws_state_access_get_user_state($user);

  if ($user_state === NULL) {
    // If the user has the permission but no state code, only deny access to restricted entities.
    return AccessResult::forbidden()
      ->addCacheContexts(['user'])
      ->addCacheTags(['user:' . $account->id()]);
  }

  // Handle user entity access.
  if ($entity_type === 'user') {
    $entity_state = fws_state_access_get_user_state($entity);

    if ($entity_state !== NULL) {
      $result = ($user_state == $entity_state);
      return $result
        ? AccessResult::allowed()->addCacheContexts(['user'])->addCacheTags(['user:' . $account->id()])
        : AccessResult::forbidden()->addCacheContexts(['user'])->addCacheTags(['user:' . $account->id()]);
    }
  }

  // Handle species_image and permit_3186a entity access.
  if ($entity_type === 'node' && in_array($bundle, ['species_image', 'permit_3186a'])) {
    $node_state = fws_state_access_get_node_state($entity);

    if ($node_state !== NULL) {
      $result = ($user_state == $node_state);

      if ($result) {
        return AccessResult::allowed()
          ->addCacheContexts(['user'])
          ->addCacheTags(['user:' . $account->id(), 'node:' . $entity->id()]);
      }
      else {
        return AccessResult::forbidden()
          ->addCacheContexts(['user'])
          ->addCacheTags(['user:' . $account->id(), 'node:' . $entity->id()]);
      }
    }
  }

  return AccessResult::neutral();
}

/**
 * Implements hook_entity_create_access().
 */
function fws_state_access_entity_create_access(AccountInterface $account, array $context, $entity_bundle) {
  // Only apply restrictions to users with state access permission.
  if (!$account->hasPermission('access state based content')) {
    return AccessResult::neutral();
  }

  // Only apply restrictions to specific entity types and bundles.
  $restricted_entities = [
    'node' => ['species_image', 'permit_3186a'],
    'user' => ['user'],
  ];

  $entity_type = $context['entity_type_id'];

  // If this is not a restricted entity type or bundle, return neutral.
  if (!isset($restricted_entities[$entity_type]) ||
      !in_array($entity_bundle, $restricted_entities[$entity_type])) {
    return AccessResult::neutral();
  }

  // Get the user's state code.
  $user = User::load($account->id());
  $user_state = fws_state_access_get_user_state($user);

  // Allow creation even if user has no state code.
  // The state code will be checked when accessing the entity later.
  return AccessResult::allowed();
}

/**
 * Implements hook_node_access().
 */
function fws_state_access_node_access(NodeInterface $node, $op, AccountInterface $account) {
  // Only handle permit_3186a and species_image nodes.
  if (!in_array($node->bundle(), ['permit_3186a', 'species_image'])) {
    return AccessResult::neutral();
  }

  // Only apply restrictions to specific operations.
  $restricted_operations = ['view', 'update', 'delete'];
  if (!in_array($op, $restricted_operations)) {
    return AccessResult::neutral();
  }

  // Check if user has the state access permission.
  if (!$account->hasPermission('access state based content')) {
    return AccessResult::neutral();
  }

  // Get the user's state code.
  $user = User::load($account->id());
  $user_state = fws_state_access_get_user_state($user);

  if ($user_state === NULL) {
    // If the user has the permission but no state code, explicitly deny access.
    return AccessResult::forbidden()
      ->addCacheContexts(['user'])
      ->addCacheTags(['user:' . $account->id(), 'node:' . $node->id()]);
  }

  // Check if the node has an owner state.
  $node_state = fws_state_access_get_node_state($node);

  if ($node_state !== NULL) {
    // If the states match, explicitly allow access.
    if ($user_state == $node_state) {
      return AccessResult::allowed()
        ->addCacheContexts(['user'])
        ->addCacheTags(['user:' . $account->id(), 'node:' . $node->id()]);
    }
    else {
      return AccessResult::forbidden()
        ->addCacheContexts(['user'])
        ->addCacheTags(['user:' . $account->id(), 'node:' . $node->id()]);
    }
  }

  return AccessResult::neutral();
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function fws_state_access_menu_local_tasks_alter(&$data, $route_name) {
  // Force access to edit tabs for state admins.
  if (strpos($route_name, 'entity.node.canonical') === 0) {
    $node = \Drupal::routeMatch()->getParameter('node');
    if ($node instanceof NodeInterface && in_array($node->bundle(), ['permit_3186a', 'species_image'])) {
      $account = \Drupal::currentUser();
      if ($account->hasPermission('access state based content')) {
        $user = User::load($account->id());
        $user_state = fws_state_access_get_user_state($user);

        if ($user_state !== NULL) {
          $node_state = fws_state_access_get_node_state($node);

          if ($node_state !== NULL && $user_state == $node_state) {
            // Force access to edit tab.
            if (isset($data['tabs'][0]['entity.node.edit_form'])) {
              $data['tabs'][0]['entity.node.edit_form']['#access'] = TRUE;
            }
          }
        }
      }
    }
  }
}

/**
 * Helper function to alter state field in user forms.
 *
 * @param array $form
 *   The form array to alter.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function _fws_state_access_alter_state_field(array &$form, FormStateInterface $form_state) {
  // Get the current logged-in user.
  $current_user = \Drupal::currentUser();

  // Check if the current user has permission to create state-based users.
  if ($current_user->hasPermission('create state based user')) {
    // Get the current user's state.
    $logged_in_user = User::load($current_user->id());

    if ($logged_in_user->hasField('field_state_cd') && !$logged_in_user->get('field_state_cd')->isEmpty()) {
      $state_term_id = $logged_in_user->get('field_state_cd')->target_id;
      $state_term = Term::load($state_term_id);

      if ($state_term && isset($form['field_state_cd'])) {
        // Get the state name.
        $state_name = $state_term->getName();

        // Set the default value for the hidden field.
        $form['field_state_cd']['widget']['#default_value'] = [$state_term_id];

        // Create a visible display that looks like a form field.
        $form['field_state_cd']['widget']['#type'] = 'item';
        $form['field_state_cd']['widget']['#title'] = t('State');
        $form['field_state_cd']['widget']['#markup'] = $state_name;
        $form['field_state_cd']['widget']['#description'] = t('State is automatically set based on your account.');
        $form['field_state_cd']['widget']['#wrapper_attributes'] = ['class' => ['form-item']];

        // Hide the actual select element.
        $form['field_state_cd']['widget'][0]['target_id']['#access'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function fws_state_access_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Check if this is a node edit form for our content types.
  if (strpos($form_id, '_node_form') !== FALSE) {
    $node = $form_state->getFormObject()->getEntity();
    if (in_array($node->bundle(), ['permit_3186a', 'species_image'])) {
      $account = \Drupal::currentUser();
      if ($account->hasPermission('access state based content')) {
        $user = User::load($account->id());
        $user_state = fws_state_access_get_user_state($user);

        if ($user_state !== NULL) {
          $node_state = fws_state_access_get_node_state($node);

          if ($node_state !== NULL && $user_state == $node_state) {
            // Add a submit handler to ensure the form can be submitted.
            $form['#validate'][] = 'fws_state_access_node_form_validate';
            $form['actions']['submit']['#submit'][] = 'fws_state_access_node_form_submit';

            // Bypass access checks for the form.
            $form['#access'] = TRUE;

            // Make sure critical fields are accessible.
            $critical_fields = [
              'title',
              'field_owner_state',
              'actions',
              'status',
              'revision_log',
            ];

            foreach ($critical_fields as $field) {
              if (isset($form[$field]) && isset($form[$field]['#access'])) {
                $form[$field]['#access'] = TRUE;
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Custom validation handler for node forms.
 */
function fws_state_access_node_form_validate($form, FormStateInterface $form_state) {
  // Remove any access-related validation errors.
  $errors = $form_state->getErrors();
  $form_state->clearErrors();

  foreach ($errors as $name => $error) {
    // Skip access-related errors.
    if (strpos($error, 'access') === FALSE) {
      $form_state->setErrorByName($name, $error);
    }
  }
}

/**
 * Custom submit handler for node forms.
 */
function fws_state_access_node_form_submit($form, FormStateInterface $form_state) {
  // Log successful submission at a lower level.
  \Drupal::logger('fws_state_access')->log(RfcLogLevel::INFO, 'Node form submitted successfully');
}

/**
 * Implements hook_preprocess_node().
 */
function fws_state_access_preprocess_node(&$variables) {
  // Add a direct edit link for state admins.
  if (in_array($variables['node']->bundle(), ['permit_3186a', 'species_image'])) {
    $account = \Drupal::currentUser();
    if ($account->hasPermission('access state based content')) {
      $user = User::load($account->id());
      $user_state = fws_state_access_get_user_state($user);

      if ($user_state !== NULL) {
        $node_state = fws_state_access_get_node_state($variables['node']);

        if ($node_state !== NULL && $user_state == $node_state) {
          $variables['content']['state_admin_edit_link'] = [
            '#type' => 'link',
            '#title' => t('Edit as State Admin'),
            '#url' => Url::fromRoute('entity.node.edit_form', ['node' => $variables['node']->id()]),
            '#attributes' => [
              'class' => ['button', 'button--primary'],
            ],
            '#weight' => -100,
          ];
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function fws_state_access_form_user_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _fws_state_access_alter_state_field($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function fws_state_access_form_user_register_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Get the current route.
  $route_name = \Drupal::routeMatch()->getRouteName();

  // Only alter the form if we're on our specific state user creation route.
  if ($route_name === 'fws_state_access.create_user') {
    _fws_state_access_alter_state_field($form, $form_state);
  }
}
