<?php

/**
 * @file
 * Primary module hooks for FWS Sighting module.
 */

use Drupal\node\NodeInterface;
use GuzzleHttp\Exception\GuzzleException;
use Drupal\taxonomy\Entity\Term;
use Drupal\user\UserInterface;
use Drupal\Core\Form\FormStateInterface;

/**
 * Get state/province from coordinates using Nominatim API.
 *
 * @param float $lat
 *   The latitude.
 * @param float $lng
 *   The longitude.
 *
 * @return string
 *   The state/province code or empty string if not found.
 */
function _fws_sighting_get_state_from_coordinates($lat, $lng) {
  try {
    $client = \Drupal::httpClient();
    // Add a user agent as required by Nominatim's usage policy.
    $url = "https://nominatim.openstreetmap.org/reverse?format=json&lat={$lat}&lon={$lng}&zoom=5";
    $response = $client->get($url, [
      'headers' => [
        'User-Agent' => 'FWS-RAF-Project/1.0',
      ],
    ]);
    $data = json_decode($response->getBody(), TRUE);

    // Extract state/province from address data.
    if (!empty($data['address'])) {
      // Try different possible fields for state/province.
      $state = $data['address']['state'] ??
               $data['address']['province'] ??
               $data['address']['state_code'] ??
               $data['address']['province_code'] ?? '';

      // If we got a full name and it's in the US or Canada, try to convert to abbreviation.
      if (!empty($state)) {
        // Common US state mappings.
        $us_states = [
          'Alabama' => 'AL',
          'Alaska' => 'AK',
          'Arizona' => 'AZ',
          'Arkansas' => 'AR',
          'California' => 'CA',
          'Colorado' => 'CO',
          'Connecticut' => 'CT',
          'Delaware' => 'DE',
          'Florida' => 'FL',
          'Georgia' => 'GA',
          'Hawaii' => 'HI',
          'Idaho' => 'ID',
          'Illinois' => 'IL',
          'Indiana' => 'IN',
          'Iowa' => 'IA',
          'Kansas' => 'KS',
          'Kentucky' => 'KY',
          'Louisiana' => 'LA',
          'Maine' => 'ME',
          'Maryland' => 'MD',
          'Massachusetts' => 'MA',
          'Michigan' => 'MI',
          'Minnesota' => 'MN',
          'Mississippi' => 'MS',
          'Missouri' => 'MO',
          'Montana' => 'MT',
          'Nebraska' => 'NE',
          'Nevada' => 'NV',
          'New Hampshire' => 'NH',
          'New Jersey' => 'NJ',
          'New Mexico' => 'NM',
          'New York' => 'NY',
          'North Carolina' => 'NC',
          'North Dakota' => 'ND',
          'Ohio' => 'OH',
          'Oklahoma' => 'OK',
          'Oregon' => 'OR',
          'Pennsylvania' => 'PA',
          'Rhode Island' => 'RI',
          'South Carolina' => 'SC',
          'South Dakota' => 'SD',
          'Tennessee' => 'TN',
          'Texas' => 'TX',
          'Utah' => 'UT',
          'Vermont' => 'VT',
          'Virginia' => 'VA',
          'Washington' => 'WA',
          'West Virginia' => 'WV',
          'Wisconsin' => 'WI',
          'Wyoming' => 'WY',
        ];

        // Canadian province mappings.
        $ca_provinces = [
          'Alberta' => 'AB',
          'British Columbia' => 'BC',
          'Manitoba' => 'MB',
          'New Brunswick' => 'NB',
          'Newfoundland and Labrador' => 'NL',
          'Nova Scotia' => 'NS',
          'Ontario' => 'ON',
          'Prince Edward Island' => 'PE',
          'Quebec' => 'QC',
          'Saskatchewan' => 'SK',
          'Northwest Territories' => 'NT',
          'Nunavut' => 'NU',
          'Yukon' => 'YT',
        ];

        // Check if we have a mapping for this state/province.
        $state = $us_states[$state] ?? $ca_provinces[$state] ?? $state;
      }

      return $state;
    }
  }
  catch (GuzzleException $e) {
    \Drupal::logger('fws_sighting')->error('Error fetching state from coordinates: @error', ['@error' => $e->getMessage()]);
    return '';
  }

  return '';
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function fws_sighting_node_presave(NodeInterface $node) {
  // Only act on sighting nodes.
  if ($node->bundle() !== 'sighting') {
    return;
  }

  // Check if auto state lookup is enabled.
  $config = \Drupal::config('fws_sighting.settings');
  if (!$config->get('auto_state_lookup')) {
    return;
  }

  // Only proceed if we have location data.
  if ($node->field_location->isEmpty()) {
    $node->field_state = NULL;
    return;
  }

  $lat = $node->field_location->lat;
  $lng = $node->field_location->lng;

  // Get state from coordinates.
  $state = _fws_sighting_get_state_from_coordinates($lat, $lng);
  $node->field_state = $state ?: NULL;

  // Update field_year based on field_date_time.
  if (!$node->field_date_time->isEmpty()) {
    $date_value = $node->field_date_time->value;
    $year = date('Y', strtotime($date_value));

    // Look for existing taxonomy term for this year.
    $term_id = \Drupal::entityQuery('taxonomy_term')
      ->condition('vid', 'year')
      ->condition('name', $year)
      ->accessCheck(FALSE)
      ->execute();

    if (empty($term_id)) {
      // Create new term if it doesn't exist.
      $term = Term::create([
        'name' => $year,
        'vid' => 'year',
      ]);
      $term->save();
      $term_id = $term->id();
    }
    else {
      $term_id = reset($term_id);
    }

    $node->set('field_year', ['target_id' => $term_id]);
  }
  else {
    $node->field_year = NULL;
  }
}

/**
 * Implements hook_page_attachments().
 */
function fws_sighting_page_attachments(array &$attachments) {
  $current_path = \Drupal::service('path.current')->getPath();
  $path_alias = \Drupal::service('path_alias.manager')->getAliasByPath($current_path);

  // Check both the system path and the alias.
  if ($current_path === '/observations-map' || $path_alias === '/observations-map' ||
      strpos($current_path, '/observations-map') === 0 || strpos($path_alias, '/observations-map') === 0) {
    \Drupal::logger('fws_sighting')->notice('Attaching sighting-count library on path: @path', ['@path' => $current_path]);
    $attachments['#attached']['library'][] = 'fws_sighting/sighting-count';
  }
}

/**
 * Implements hook_theme().
 */
function fws_sighting_theme() {
  return [
    'fws_sighting_count' => [
      'template' => 'fws-sighting-count',
      'variables' => [],
    ],
  ];
}

/**
 * Implements hook_node_insert().
 */
function fws_sighting_node_insert(NodeInterface $node) {
  // Only act on sighting nodes.
  if ($node->getType() != 'sighting') {
    return;
  }

  // Check if field_spotter exists and is empty.
  if ($node->hasField('field_spotter') && empty($node->get('field_spotter')->value)) {
    // Get the node author.
    $author = $node->getOwner();

    // Check if the author has first and last name fields.
    if ($author && $author->hasField('field_first_name') && $author->hasField('field_last_name')) {
      $first_name = $author->get('field_first_name')->value;
      $last_name = $author->get('field_last_name')->value;

      // If both first and last name are available, use them.
      if (!empty($first_name) && !empty($last_name)) {
        $spotter_name = $first_name . ' ' . $last_name;
        $node->set('field_spotter', $spotter_name);
        $node->save();
      }
      // If only one is available, use what we have.
      elseif (!empty($first_name)) {
        $node->set('field_spotter', $first_name);
        $node->save();
      }
      elseif (!empty($last_name)) {
        $node->set('field_spotter', $last_name);
        $node->save();
      }
      // If neither first nor last name is available, use the email address.
      else {
        $node->set('field_spotter', $author->getEmail());
        $node->save();
      }
    }
    // If the author doesn't have first/last name fields, use the email address.
    else {
      $node->set('field_spotter', $author->getEmail());
      $node->save();
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function fws_sighting_user_insert(UserInterface $user) {
  // Get all roles assigned to the user.
  $roles = $user->getRoles();

  // Log the current roles for debugging.
  \Drupal::logger('fws_sighting')->notice('User @uid has roles: @roles', [
    '@uid' => $user->id(),
    '@roles' => implode(', ', $roles),
  ]);

  // All users have the authenticated role by default.
  // If that's the only role, then add the spotter role.
  if (count($roles) == 1 && in_array('authenticated', $roles)) {
    // Check if the spotter role exists.
    $role_storage = \Drupal::entityTypeManager()->getStorage('user_role');
    $spotter_role = $role_storage->load('spotter');

    if ($spotter_role) {
      // Add the spotter role.
      $user->addRole('spotter');

      // Explicitly save the user to ensure the role is added.
      $user->save();

      // Log this event.
      \Drupal::logger('fws_sighting')->notice('Added spotter role to new user @uid during creation', [
        '@uid' => $user->id(),
      ]);

      // Verify that the role was actually added.
      $updated_roles = $user->getRoles();
      \Drupal::logger('fws_sighting')->notice('After update, user @uid has roles: @roles', [
        '@uid' => $user->id(),
        '@roles' => implode(', ', $updated_roles),
      ]);
    }
    else {
      \Drupal::logger('fws_sighting')->error('Could not add spotter role because it does not exist in the system');
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function fws_sighting_form_openid_connect_login_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Add a notice about Login.gov auto-registration at the top of the form.
  $form['login_notice'] = [
    '#type' => 'html_tag',
    '#tag' => 'div',
    '#value' => t('<strong>Need an account?</strong> The Login.gov button below will automatically create an account for you if you do not already have one, or log you in if you do have an account.'),
    '#attributes' => [
      'class' => ['alert', 'alert-info', 'margin-bottom-lg'],
    ],
    '#weight' => -100,
  ];
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function fws_sighting_form_user_login_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Add spacing between elements in the login form.
  if (isset($form['fws_terms_conditions'])) {
    $form['fws_terms_conditions']['#prefix'] = '<div class="margin-top-lg margin-bottom-lg">';
    $form['fws_terms_conditions']['#suffix'] = '</div>';
  }

  if (isset($form['saml_login'])) {
    $form['saml_login']['#attributes']['class'][] = 'margin-top-lg';
    $form['saml_login']['#prefix'] = '<div class="margin-top-lg">';
    $form['saml_login']['#suffix'] = '</div>';
  }
}

/**
 * Implements hook_form_views_exposed_form_alter().
 */
function fws_sighting_form_views_exposed_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  $view = $form_state->get('view');
  if ($view->id() == 'sightings_map') {

    if (isset($form['field_year_target_id'])) {
      // Get the cutoff date.
      $cutoff_date = _fws_sighting_get_cutoff_date();
      // Loop through all year names to return the ones later than this date.
      foreach ($form['field_year_target_id']['#options'] as $key => $option) {
        if (is_numeric($option) && $option < $cutoff_date) {
          unset($form['field_year_target_id']['#options'][$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_views_query_alter().
 */
function fws_sighting_views_query_alter($view, $query) {
  if ($view->id() == 'sightings_map') {
    foreach ($query->where as &$condition_group) {
      foreach ($condition_group['conditions'] as $key => &$condition) {
        // Look for the condition that filters the date after 2010.
        if (is_array($condition) &&
            !empty($condition['field'] &&
            strpos($condition['field'], 'field_date_time_value') !== FALSE &&
            $condition['operator'] == 'formula')) {
          $cutoff_date = _fws_sighting_get_cutoff_date() . '-01-01';
          $condition['field'] = str_replace('2010-01-01', $cutoff_date, $condition['field']);
        }
      }
    }
  }
}

/**
 * Get the cutoff date for sightings in observation map.
 *
 * @return string
 *   The year.
 */
function _fws_sighting_get_cutoff_date() {
  $date = new DateTime();
  $date->modify('-15 years');
  return $date->format('Y');
}
